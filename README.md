# Keeper

Keeper simplifies storage of state. Just point where it should be saved, and keeper takes care of the rest. You don't need to write code to load, save, and convert data, keeper takes care of that for you.

## 📜 Features

- ✅ Sync storage
- 🚧 Async storage*
  - ✅ Store single async value
  - ❌ Store value in sync key
- ❌ MobX store support
- ❌ Function types
- ❌ Observe storage changes
- ✅ Extensible for many storage containers

Supported storage containers:

- ✅ In-memory storage 
- ✅ Hive storage (through [keeper_hive](https://pub.dev/packages/keeper_hive))

<sub>* **supports one async annotation per field**, sync annotation not supported for asynchronous field</sub>

<sub>✅ Available | 🚧 Under development | ❌ Unsupported</sub>

## 🛠️ Getting started

Keeper relies on code generation to save you the trouble of writing storage code. The code is generated by [keeper_codegen](https://pub.dev/packages/keeper_codegen) which requires [build_runner](https://pub.dev/packages/build_runner).

⚠️ This is an experimental project. Use with caution.

## 💻 Usage

In `pubspec.yaml`:

```yaml
dependencies:
  keeper: ^0.0.1

dev_dependencies:
  build_runner: ^2.1.5 # check for recent version on pub.dev
  keeper_codegen: ^0.0.1 # check for recent version on pub.dev
```

In your Dart file import `keeper`:

```dart
import 'package:keeper/keeper.dart';
```

Set up the storage key:

```dart
KeepKey counterValue() => MemoryKeep().key('counter_value');
```

And set up the class:

```dart
part 'counter.g.dart';

class Counter = _Counter with _$CounterKeeper;

@kept
class _Counter {
  @At(counterValue)
  int value = 0;

  void increment() {
    value++;
  }
}
```

When the value changes it will now be automatically stored.

Different storage mechanisms may require different initialization.

## ℹ️ Additional information

Contributions and bug reports are welcomed! Please include relevant information to help solve the bugs.

This project is licensed under The MIT License (MIT) available at [LICENSE](./LICENSE).